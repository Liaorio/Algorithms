x = 91;
y = 100;
while (y > 0)
  if (x > 100) {
    x = x - 10;
    y--;
  } else x++;

  T(n) = O(1);
 // 这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?
 // 没。这段程序的运行是和n无关的，

 x=1;
for(i=1;i<=n;i++)
       for(j=1;j<=i;j++)
          for(k=1;k<=j;k++)
              x++; 　　
// 该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：  则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)

i=n-1;
while(i>=0&&(A[i]!=k))
      i--;
return i;
// 此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。
